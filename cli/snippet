#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const https = require('https');
const http = require('http');

// Configuration
const CONFIG_FILE = path.join(process.env.HOME, '.snippet-cli.json');
const QUEUE_FILE = path.join(process.env.HOME, '.snippet-cli-queue.json');

// Helper to read config
function loadConfig() {
  if (!fs.existsSync(CONFIG_FILE)) {
    console.error('‚ùå Not configured. Run: snippet config');
    process.exit(1);
  }
  return JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));
}

// Helper to save config
function saveConfig(config) {
  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));
  console.log('‚úÖ Configuration saved');
}

// Queue management for offline support
function loadQueue() {
  if (!fs.existsSync(QUEUE_FILE)) {
    return [];
  }
  try {
    return JSON.parse(fs.readFileSync(QUEUE_FILE, 'utf8'));
  } catch (error) {
    console.error('‚ö†Ô∏è  Warning: Could not read queue file');
    return [];
  }
}

function saveQueue(queue) {
  fs.writeFileSync(QUEUE_FILE, JSON.stringify(queue, null, 2));
}

function addToQueue(snippetData) {
  const queue = loadQueue();
  queue.push({
    data: snippetData,
    timestamp: Date.now()
  });
  saveQueue(queue);
  console.log('üì• Saved to offline queue (will sync when online)');
  console.log(`   Queue size: ${queue.length} snippet(s)`);
}

async function syncQueue(config) {
  const queue = loadQueue();

  if (queue.length === 0) {
    return;
  }

  console.log(`üîÑ Syncing ${queue.length} queued snippet(s)...`);

  const failed = [];
  let synced = 0;

  for (const item of queue) {
    try {
      await apiRequest('/snippets', 'POST', item.data, config.jwtToken, config.apiUrl);
      synced++;
    } catch (error) {
      failed.push(item);
    }
  }

  if (synced > 0) {
    console.log(`‚úÖ Synced ${synced} queued snippet(s)`);
  }

  if (failed.length > 0) {
    console.log(`‚ö†Ô∏è  ${failed.length} snippet(s) still offline`);
    saveQueue(failed);
  } else {
    // Clear queue file
    if (fs.existsSync(QUEUE_FILE)) {
      fs.unlinkSync(QUEUE_FILE);
    }
  }
}

// Helper to make API requests
function apiRequest(endpoint, method, data, token, apiUrl) {
  return new Promise((resolve, reject) => {
    // Properly concatenate URL - remove leading slash from endpoint if apiUrl ends with /
    const fullUrl = apiUrl.endsWith('/') ? apiUrl + endpoint.replace(/^\//, '') : apiUrl + endpoint;
    const url = new URL(fullUrl);
    const isHttps = url.protocol === 'https:';
    const client = isHttps ? https : http;

    const options = {
      hostname: url.hostname,
      port: url.port || (isHttps ? 443 : 80),
      path: url.pathname + url.search,
      method: method,
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      }
    };

    const req = client.request(options, (res) => {
      let body = '';
      res.on('data', chunk => body += chunk);
      res.on('end', () => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          resolve(JSON.parse(body));
        } else {
          reject(new Error(`HTTP ${res.statusCode}: ${body}`));
        }
      });
    });

    req.on('error', reject);

    if (data) {
      req.write(JSON.stringify(data));
    }

    req.end();
  });
}

// Add sensible paragraph breaks to long text
function addParagraphBreaks(text) {
  // If text already has paragraph breaks (double newlines), return as-is
  if (text.includes('\n\n')) {
    return text;
  }

  // If text has single newlines, return as-is (respect original formatting)
  if (text.includes('\n')) {
    return text;
  }

  // Only process long text blocks without any line breaks
  if (text.length < 200) {
    return text;
  }

  // Split into sentences (basic heuristic: period/question/exclamation followed by space and capital)
  const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];

  if (sentences.length <= 2) {
    return text; // Too short to break up
  }

  // Group into paragraphs of 2-4 sentences
  const paragraphs = [];
  let currentParagraph = [];

  sentences.forEach((sentence, i) => {
    currentParagraph.push(sentence.trim());

    // Create paragraph break after 2-4 sentences, or at the end
    if (currentParagraph.length >= 3 || i === sentences.length - 1) {
      paragraphs.push(currentParagraph.join(' '));
      currentParagraph = [];
    }
  });

  return paragraphs.join('\n\n');
}

// Commands
const commands = {
  config: () => {
    console.log('üîß Snippet CLI Configuration\n');

    const readline = require('readline');
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    const config = {};

    rl.question('API URL (default: http://localhost:5001/api): ', (apiUrl) => {
      config.apiUrl = apiUrl.trim() || 'http://localhost:5001/api';

      rl.question('JWT Token: ', (token) => {
        config.jwtToken = token.trim();

        rl.close();
        saveConfig(config);
      });
    });
  },

  save: async (args) => {
    const config = loadConfig();
    const text = args.join(' ');

    if (!text) {
      console.error('‚ùå No text provided');
      console.log('Usage: snippet save <text>');
      console.log('   Or: echo "text" | snippet save');
      process.exit(1);
    }

    const cleanedText = addParagraphBreaks(text);
    const title = cleanedText.substring(0, 50).trim() + (cleanedText.length > 50 ? '...' : '');

    const snippetData = {
      title: title,
      type: 'excerpt',
      content: cleanedText,
      source: 'CLI',
      priority: 'medium',
      inQueue: true,
      topics: []
    };

    // First, try to sync any queued snippets
    try {
      await syncQueue(config);
    } catch (err) {
      // Continue even if sync fails
    }

    // Now try to save the new snippet
    try {
      await apiRequest('/snippets', 'POST', snippetData, config.jwtToken, config.apiUrl);
      console.log('‚úÖ Snippet saved!');
      console.log(`   "${title}"`);
    } catch (err) {
      // Check if it's a network error
      if (err.code === 'ENOTFOUND' || err.code === 'ECONNREFUSED' || err.code === 'ETIMEDOUT' || err.message.includes('getaddrinfo')) {
        console.log('‚ö†Ô∏è  No internet connection');
        addToQueue(snippetData);
      } else {
        console.error('‚ùå Failed to save snippet:', err.message);
        process.exit(1);
      }
    }
  },

  image: async (args) => {
    const config = loadConfig();
    const imagePath = args[0];

    if (!imagePath) {
      console.error('‚ùå No image path provided');
      console.log('Usage: snippet image <path>');
      process.exit(1);
    }

    if (!fs.existsSync(imagePath)) {
      console.error('‚ùå Image file not found:', imagePath);
      process.exit(1);
    }

    // Read image and convert to base64
    const imageBuffer = fs.readFileSync(imagePath);
    const ext = path.extname(imagePath).toLowerCase();
    let mimeType = 'image/png';

    if (ext === '.jpg' || ext === '.jpeg') mimeType = 'image/jpeg';
    if (ext === '.gif') mimeType = 'image/gif';
    if (ext === '.webp') mimeType = 'image/webp';

    const base64data = `data:${mimeType};base64,${imageBuffer.toString('base64')}`;

    // Check size (300KB limit)
    if (imageBuffer.length > 300 * 1024) {
      console.error('‚ùå Image too large (max 300KB)');
      process.exit(1);
    }

    const filename = path.basename(imagePath);
    const snippetData = {
      title: `Image: ${filename}`,
      type: 'excerpt',
      imageData: base64data,
      source: 'CLI',
      priority: 'medium',
      inQueue: true,
      topics: []
    };

    // First, try to sync any queued snippets
    try {
      await syncQueue(config);
    } catch (err) {
      // Continue even if sync fails
    }

    // Now try to save the image
    try {
      await apiRequest('/snippets', 'POST', snippetData, config.jwtToken, config.apiUrl);
      console.log('‚úÖ Image saved!');
      console.log(`   ${filename}`);
    } catch (err) {
      // Check if it's a network error
      if (err.code === 'ENOTFOUND' || err.code === 'ECONNREFUSED' || err.code === 'ETIMEDOUT' || err.message.includes('getaddrinfo')) {
        console.log('‚ö†Ô∏è  No internet connection');
        addToQueue(snippetData);
      } else {
        console.error('‚ùå Failed to save image:', err.message);
        process.exit(1);
      }
    }
  },

  help: () => {
    console.log(`
üìö Snippet CLI - Save text and images to your Snippet library

Commands:
  config              Configure API URL and authentication token
  save <text>         Save text as a snippet
  image <path>        Save an image as a snippet
  help                Show this help message

Examples:
  snippet config
  snippet save "This is some important text I want to remember"
  snippet image ~/Desktop/screenshot.png
  echo "Piped text" | snippet save

Keyboard Shortcut Integration:
  - macOS Shortcuts: Use "Run Shell Script" action with this CLI
  - Keyboard Maestro: Execute shell script with selected text
  - BetterTouchTool: Trigger shell script with hotkey
    `);
  }
};

// Main
const args = process.argv.slice(2);

if (args.length === 0) {
  // Check if stdin has data (piped input)
  if (process.stdin.isTTY) {
    commands.help();
  } else {
    // Read from stdin
    let stdinData = '';
    process.stdin.on('data', chunk => stdinData += chunk);
    process.stdin.on('end', () => {
      commands.save([stdinData.trim()]);
    });
  }
} else {
  const command = args[0];
  const commandArgs = args.slice(1);

  if (commands[command]) {
    commands[command](commandArgs);
  } else {
    console.error(`‚ùå Unknown command: ${command}`);
    commands.help();
    process.exit(1);
  }
}
